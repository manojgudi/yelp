#!/usr/bin/python2.7	

# multi-line comment  => done
# multi-line uncomment => done
# single var  handle exec and loops
# show diff after execution
# handle ; and missing end

import argparse

# Colors
HEADER = '\033[95m'
OKBLUE = '\033[94m'
OKGREEN = '\033[92m'
WARNING = '\033[93m'
FAIL = '\033[91m'
ENDC = '\033[0m'



parser = argparse.ArgumentParser(description="A simple script to save you from mildly terrible scilab scripting \n www.github.com/manojgudi/yelp")
parser.add_argument("file", help="requires a valid file name")

group = parser.add_mutually_exclusive_group()
group.add_argument("-c","--comment_all", help="multi-line comment given document specified by ##  markers", action="store_true")
group.add_argument("-u", "--uncomment_all", help="multi-line UNcomment if previously commented using yelp", action = "store_true")
parser.add_argument("-f", help="Force the script to write changes directly to the file", action="store_true")
parser.add_argument("-d", help="Show diff", action="store_true")


args = parser.parse_args()

# File opening and read it into file_data variable
file_obj = open(args.file, 'r')
file_data = file_obj.read()
file_obj.close()


def list2fstr(list_data):
	# Opposite of string.splitlines() function, list to formatted string
	formatted_string = ""
	for i in list_data:
		formatted_string = formatted_string + i + "\n"
		
	return formatted_string

def comment_all(str_data):
	# Check for number of ##, if the number is odd, then user is on way to destroy code
	if str_data.count("##")%2 != 0:
		print("There are odd number of ## markers in document, please correct it")
		return (-1)
	else:
		list_data = str_data.splitlines()
		
		count = 0
		start_marker = []
		end_marker = []

		# iterating for each sentence
		for i in list_data:
			count+=1
			if i.startswith("##"):
				start_marker.append(count)
			elif i.endswith("##"):
				end_marker.append(count)
		
		if len(start_marker) == 0:
			print(WARNING+"Either there are NO comment_markers or they are misplaced \nPlease consider rediting your file"+ENDC)
			exit()
								
		for i in start_marker:
			line_iterator = range((i-1),(end_marker[start_marker.index(i)])) # Use of (i-1) so that it includes the line which contains #

			# Add // to those section
			for j in line_iterator:
				
				# Shows what all is deleted
				"""if args.d:
					print("--"+FAIL+list_data[j]+ENDC)"""
					
				list_data[j] = "//" + list_data[j]			
				
				# Shows what all is modified
				if args.d:
					print("++ "+OKBLUE+list_data[j]+ENDC)
					
		# Convert list_data to a string modified_content
		modified_content = list2fstr(list_data)
					
		# If --force option is set, then write in same file
		if args.f:
			# reopen original file
			file_obj = open(args.file, 'w')
			file_obj.write(modified_content)
			file_obj.close()
		else:
			write_other_file = open("mod_"+args.file, 'w')
			write_other_file.write(modified_content)
			write_other_file.close()

def uncomment_all(str_data):
        list_data = str_data.splitlines()
        count = 0
        start_marker = []
        end_marker = []

        # iterating for each sentence
        for i in list_data:
                count+=1
                if i.startswith("//##"):
                        start_marker.append(count)
                elif i.endswith("##"):
                        end_marker.append(count)
        
        if len(start_marker) == 0:
                print(WARNING+"Either there are NO comment_markers or they are misplaced \nPlease consider rediting your file"+ENDC)
                exit()
                                                        
        for i in start_marker:
                line_iterator = range((i-1),(end_marker[start_marker.index(i)])) # Use of (i-1) so that it includes the line which contains #

                # Add // to those section
                for j in line_iterator:
                        list_data[j] =  list_data[j].strip("//")
			# Shows what all is modified
			if args.d:
				print("++ "+OKGREEN+list_data[j]+ENDC)
        
        # Convert list_data to a string modified_content
        modified_content = list2fstr(list_data)
                
        # If --force option is set, then write in same file
        if args.f:
                # reopen original file
                file_obj = open(args.file, 'w')
                file_obj.write(modified_content)
                file_obj.close()
        else:
                write_other_file = open("mod_"+args.file, 'w')
                write_other_file.write(modified_content)
                write_other_file.close()

def rm_comments(list_data):
	list_pass_void_comments = []
	for i in list_data:
		if i.startswith("//") or i.find("##") != -1:
			pass
		else:
			list_pass_void_comments.append(i)

	return list_pass_void_comments
	
""" Might require someday
def rm_statement(list_data):
	list_pass_void_exec = []
	for i in list_data:
		if (i.find("exec") == -1) and (i.find("endfunction") == -1) and  (i.find("end") == -1):
			list_pass_void_exec.append(i)

	return list_pass_void_exec
"""

def expand_exec(list_data):
	# Make sure list_data doesnt contain comments
	current_string=list2fstr(list_data)
	for i in list_data:
		if (i.find("exec") != -1):
			hfile =open(i.partition("exec")[2].strip(" "), 'r')
			current_string = hfile.read() + current_string
	
	return current_string.splitlines()
			
			

""" Might Require some day
def rm_symbols(str_line):
	dic = [",","]","[","(",")",";","&",":","=","$"]
	clean_str = ""
	# str.strip("character")  is not efficient
	for i in str_line:
		for j in dic:
			
		
	return clean_str
"""
	
def find_single_variable(str_data):
	list_data = str_data.splitlines() 
	
	# Remove comments and exec statments
	list_data = rm_comments(list_data)
	
	expand_exec(list_data)
	
	"""words = []
	for i in list_data:
		i = rm_symbols(i)
		temp_list = i.split()
		for j in temp_list:
			words.append(j)
	
	print words
	"""		
	#content = list2fstr(list_data)		
	#return content
	



# check for -c and -u flags
if args.comment_all:
	print "commenting file"
	comment_all(file_data)
if args.uncomment_all:
	print "uncommenting file"
	uncomment_all(file_data)

find_single_variable(file_data)
